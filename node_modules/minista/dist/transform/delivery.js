import picomatch from "picomatch";
import { parse as parseHtml } from "node-html-parser";
import { flags } from "../config/system.js";
import { getElements, cleanElement } from "../utility/element.js";
const cleanAttributes = ["data-minista-transform-target"];
function getDeliveryItems({
  ssgPages,
  config
}) {
  const { include, exclude, trimTitle, sortBy } = config.main.delivery;
  const filterdPages = ssgPages.filter((page) => {
    return picomatch.isMatch(page.path, include, {
      ignore: exclude
    });
  });
  if (!filterdPages.length) {
    return [];
  }
  return filterdPages.map((page) => {
    let title;
    title = page.title ? page.title : "";
    if (!title) {
      const pTitle = page.html.match(
        /<title[^<>]*?>\s*\n*(.*?)\s*\n*<\/title>/i
      );
      title = pTitle ? pTitle[1] : "";
    }
    const regTrimTitle = new RegExp(trimTitle);
    title = title ? title.replace(regTrimTitle, "") : "";
    return {
      group: page.group,
      title,
      path: page.path,
      draft: page.draft
    };
  }).sort((a, b) => {
    let itemA;
    let itemB;
    itemA = sortBy === "path" ? a.path.toUpperCase() : a.title;
    itemB = sortBy === "path" ? b.path.toUpperCase() : b.title;
    if (itemA < itemB) {
      return -1;
    }
    if (itemA > itemB) {
      return 1;
    }
    return 0;
  });
}
function getDeliveryGroups(items) {
  if (!items.length) {
    return [];
  }
  const groupTitles = [...new Set(items.map((item) => item.group))].sort();
  let groups = groupTitles.map((item) => {
    return { title: item, items: [] };
  });
  items.map((item) => {
    const itemObj = { title: item.title, path: item.path, draft: item.draft };
    const target = groups.find((group) => group.title === item.group);
    target && target.items.push(itemObj);
    return;
  });
  return groups;
}
function getDeliveryTag({
  title,
  items,
  hasRelativeFlag
}) {
  if (!items.length) {
    return "";
  }
  const flag = hasRelativeFlag ? `
      ${flags.relative}` : "";
  const titleStr = title ? `
<h2 class="minista-delivery-nav-title">${title}</h2>
` : "";
  const listStr = items.map((item) => {
    const draftStr = item.draft ? " is-draft" : "";
    return `<li class="minista-delivery-item${draftStr}">
  <div class="minista-delivery-item-content">
    <a
      class="minista-delivery-item-content-link"
      href="${item.path}"${flag}
    ></a>
    <div class="minista-delivery-item-content-inner">
      <p class="minista-delivery-item-content-name">${item.title}</p>
      <p class="minista-delivery-item-content-slug">${item.path}</p>
    </div>
    <div class="minista-delivery-item-content-background"></div>
  </div>
</li>`;
  }).join("\n");
  return `<nav class="minista-delivery-nav">${titleStr}
<ul class="minista-delivery-list">
${listStr}
</ul>
</nav>`;
}
function transformDeliveries({
  parsedData,
  ssgPages,
  config
}) {
  const { base } = config.main;
  const targetAttr = `[data-minista-transform-target="delivery"]`;
  const targetEls = getElements(parsedData, targetAttr);
  if (!targetEls.length || !ssgPages.length) {
    return;
  }
  const items = getDeliveryItems({ ssgPages, config });
  const groups = getDeliveryGroups(items);
  const insertTags = groups.map((group) => {
    return getDeliveryTag({
      title: group.title,
      items: group.items,
      hasRelativeFlag: base === "" || base === "./"
    });
  });
  const insertTag = insertTags.join("\n");
  const insertEl = parseHtml(insertTag);
  targetEls.map((el) => {
    el.parentNode.exchangeChild(el, insertEl);
    cleanElement(el, cleanAttributes);
    return;
  });
}
export {
  getDeliveryGroups,
  getDeliveryItems,
  getDeliveryTag,
  transformDeliveries
};
