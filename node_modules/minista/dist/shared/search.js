import { Fragment, jsx, jsxs } from "react/jsx-runtime";
import { useState, useEffect } from "react";
function compNum(a, b) {
  return a - b;
}
function Search(props) {
  const {
    placeholder = props.placeholder || "",
    minHitLength = props.minHitLength || 2,
    maxHitPages = props.maxHitPages || 5,
    maxHitWords = props.maxHitWords || 20,
    searchFieldInsertBeforeElement,
    searchFieldInsertAfterElement,
    searchFieldClassName,
    searchListClassName,
    ...attributes
  } = props;
  const [searchValues, setSearchValues] = useState([]);
  const [searchHitValues, setSearchHitValues] = useState([]);
  const [searchResults, setSearchResults] = useState([]);
  return /* @__PURE__ */ jsxs("div", { ...attributes, children: [
    /* @__PURE__ */ jsx(
      SearchField,
      {
        className: searchFieldClassName,
        placeholder,
        minHitLength,
        maxHitPages,
        maxHitWords,
        insertBeforeElement: searchFieldInsertBeforeElement,
        insertAfterElement: searchFieldInsertAfterElement,
        setSearchValues,
        setSearchHitValues,
        setSearchResults
      }
    ),
    /* @__PURE__ */ jsx(
      SearchList,
      {
        className: searchListClassName,
        searchValues,
        searchHitValues,
        searchResults
      }
    )
  ] });
}
function SearchField(props) {
  const {
    placeholder = props.placeholder || "",
    minHitLength = props.minHitLength || 2,
    maxHitPages = props.maxHitPages || 5,
    maxHitWords = props.maxHitWords || 20,
    insertBeforeElement,
    insertAfterElement,
    setSearchValues,
    setSearchHitValues,
    setSearchResults,
    ...attributes
  } = props;
  const [callSearchData, setCallSearchData] = useState(false);
  const [searchData, setSearchData] = useState({
    words: [],
    hits: [],
    pages: []
  });
  const [searchHits, setSearchHits] = useState([]);
  const [searchPages, setSearchPages] = useState([]);
  const searchHandler = (event) => {
    if (!callSearchData) {
      setCallSearchData(true);
    }
    if (!searchData || !searchHits || !searchPages) {
      return;
    }
    const inputValues = event.target.value.split(" ");
    const mergedInputValues = [...new Set(inputValues)].sort();
    const hitValues = mergedInputValues.map((value) => {
      if (value.length >= minHitLength) {
        return searchHits.filter((hit) => {
          return new RegExp(value, "i").test(hit);
        });
      } else {
        return [];
      }
    });
    const mergedHitValues = [...new Set(hitValues.flat())].sort();
    const hitIndexes = mergedHitValues.map((value) => {
      return searchData.words.indexOf(value);
    });
    const hitPages = searchPages.flatMap((page) => {
      const titleIndexs = page.title.filter((i) => hitIndexes.indexOf(i) !== -1);
      const contentIndexs = page.content.filter(
        (i) => hitIndexes.indexOf(i) !== -1
      );
      if (titleIndexs.length || contentIndexs.length) {
        return {
          path: page.path,
          title: titleIndexs,
          toc: page.toc,
          content: contentIndexs
        };
      } else {
        return [];
      }
    });
    const sortedHitPages = [...new Set(hitPages)].sort((a, b) => {
      if (a.title.length !== b.title.length) {
        return (a.title.length - b.title.length) * -1;
      }
      if (a.content.length !== b.content.length) {
        return (a.content.length - b.content.length) * -1;
      }
      return 0;
    }).slice(0, maxHitPages);
    const resultHitPages = sortedHitPages.map((page) => {
      const targetPage = searchData.pages.find(
        (dataPage) => dataPage.path === page.path
      );
      if (page.title.length) {
        const targetContent = targetPage.title.map((num) => searchData.words[num]).join(" ");
        return {
          path: targetPage.path,
          content: targetContent
        };
      } else {
        let getTargetId2 = function(targetIndex2, toc) {
          if (!toc.length) {
            return "";
          }
          const targetToc = page.toc.filter((item) => targetIndex2 >= item[0]).slice(-1)[0];
          const targetId2 = targetToc ? "#" + targetToc[1] : "";
          return targetId2;
        };
        var getTargetId = getTargetId2;
        const targetWord = page.content[0];
        const targetIndex = targetPage.content.indexOf(targetWord);
        const targetIndexes = targetPage.content.slice(
          targetIndex,
          targetIndex + maxHitWords
        );
        const targetWords = targetIndexes.map((num) => searchData.words[num]).join("");
        const targetContent = "..." + targetWords + "...";
        const targetId = getTargetId2(targetIndex, page.toc);
        return {
          path: targetPage.path + targetId,
          content: targetContent
        };
      }
    });
    if (setSearchValues) {
      const filterdInputValues = mergedInputValues.filter(
        (value) => value && !value.includes(" ")
      );
      setSearchValues(filterdInputValues);
    }
    if (setSearchHitValues) {
      setSearchHitValues(mergedHitValues);
    }
    if (setSearchResults) {
      setSearchResults(resultHitPages);
    }
    return;
  };
  useEffect(() => {
    if (callSearchData) {
      const getSearchData = async () => {
        const filePath = "/@minista-temp/__minista_plugin_search.json";
        const response = await fetch(filePath);
        const data = await response.json();
        setSearchData(data);
        if (data.words && data.hits) {
          const hitWords = [];
          await Promise.all(
            data.hits.map(async (hit) => {
              return hitWords.push(data.words[hit]);
            })
          );
          setSearchHits(hitWords);
        }
        if (data.words && data.pages) {
          const optimizePages = [];
          await Promise.all(
            data.pages.map(async (page) => {
              return optimizePages.push({
                path: page.path,
                title: [...new Set(page.title)].sort(compNum),
                toc: page.toc,
                content: [...new Set(page.content)].sort(compNum)
              });
            })
          );
          setSearchPages(optimizePages);
        }
      };
      getSearchData();
    }
  }, [callSearchData]);
  return /* @__PURE__ */ jsxs("div", { ...attributes, children: [
    insertBeforeElement,
    /* @__PURE__ */ jsx(
      "input",
      {
        type: "search",
        "data-full-text-search": "",
        placeholder,
        onChange: searchHandler
      }
    ),
    insertAfterElement
  ] });
}
function SearchList(props) {
  const { searchValues, searchHitValues, searchResults, ...attributes } = props;
  const checkValues = searchValues && searchValues.length;
  const checkHitValues = searchHitValues && searchHitValues.length;
  const checkResults = searchResults && searchResults.length;
  if (checkValues && checkHitValues && checkResults) {
    const regValues = new RegExp(`(${searchValues.join("|")})`, "ig");
    const regHitValues = new RegExp(`(${searchHitValues.join("|")})`, "ig");
    return /* @__PURE__ */ jsx("ul", { ...attributes, children: searchResults.map((item, index) => {
      const words = item.content.split(regHitValues);
      const filteredWords = words.filter((word) => word && word.length > 0);
      const renderdWords = filteredWords.map((word, wordIndex) => {
        if (word.match(regHitValues)) {
          const glyphs = word.split(regValues);
          const renderdGlyphs = glyphs.map((glyph, glyphIndex) => {
            if (glyph.match(regValues)) {
              return /* @__PURE__ */ jsx("mark", { children: glyph }, glyphIndex);
            } else {
              return /* @__PURE__ */ jsx("span", { children: glyph }, glyphIndex);
            }
          });
          return /* @__PURE__ */ jsx("span", { children: renderdGlyphs }, wordIndex);
        } else {
          return /* @__PURE__ */ jsx("span", { children: word }, wordIndex);
        }
      });
      const content = renderdWords;
      return /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsx("a", { href: item.path, children: /* @__PURE__ */ jsxs("div", { children: [
        /* @__PURE__ */ jsx("p", { children: /* @__PURE__ */ jsx("strong", { children: content }) }),
        /* @__PURE__ */ jsx("p", { children: /* @__PURE__ */ jsx("small", { children: item.path }) })
      ] }) }) }, index);
    }) });
  } else if (checkResults) {
    return /* @__PURE__ */ jsx("ul", { ...attributes, children: searchResults.map((item, index) => {
      return /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsx("a", { href: item.path, children: /* @__PURE__ */ jsxs("div", { children: [
        /* @__PURE__ */ jsx("p", { children: /* @__PURE__ */ jsx("strong", { children: item.content }) }),
        /* @__PURE__ */ jsx("p", { children: /* @__PURE__ */ jsx("small", { children: item.path }) })
      ] }) }) }, index);
    }) });
  } else {
    return /* @__PURE__ */ jsx(Fragment, {});
  }
}
export {
  Search,
  SearchField,
  SearchList
};
